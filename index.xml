<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gin Web Framework</title>
    <link>https://gin-gonic.com/</link>
    <description>Recent content on Gin Web Framework</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 25 Sep 2018 16:57:20 +0200</lastBuildDate>
    
	<atom:link href="https://gin-gonic.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Installation</title>
      <link>https://gin-gonic.com/documentation/getting-started/installation/</link>
      <pubDate>Tue, 25 Sep 2018 16:57:20 +0200</pubDate>
      
      <guid>https://gin-gonic.com/documentation/getting-started/installation/</guid>
      <description>To install Gin package, you need to install Go and set your Go workspace first.
 Download and install it:
go get -u github.com/gin-gonic/gin   Import it in your code:  import &amp;quot;github.com/gin-gonic/gin&amp;quot;  (Optional) Import net/http. This is required for example if using constants such as http.StatusOK.
import &amp;quot;net/http&amp;quot;   Copy a starting template inside your project  curl https://raw.githubusercontent.com/gin-gonic/gin/master/examples/basic/main.go &amp;gt; main.go  Run your project
go run main.</description>
    </item>
    
    <item>
      <title>Custom configuration</title>
      <link>https://gin-gonic.com/documentation/extra/custom_config/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/extra/custom_config/</guid>
      <description>Use http.ListenAndServe() directly, like this:
func main() { router := gin.Default() http.ListenAndServe(&amp;quot;:8080&amp;quot;, router) }  or
func main() { router := gin.Default() s := &amp;amp;http.Server{ Addr: &amp;quot;:8080&amp;quot;, Handler: router, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 &amp;lt;&amp;lt; 20, } s.ListenAndServe() }  </description>
    </item>
    
    <item>
      <title>Custom validators</title>
      <link>https://gin-gonic.com/documentation/binding/custom_validators/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/binding/custom_validators/</guid>
      <description>It is also possible to register custom validators. See the example code.
package main import ( &amp;quot;net/http&amp;quot; &amp;quot;reflect&amp;quot; &amp;quot;time&amp;quot; &amp;quot;github.com/gin-gonic/gin&amp;quot; &amp;quot;github.com/gin-gonic/gin/binding&amp;quot; &amp;quot;gopkg.in/go-playground/validator.v8&amp;quot; ) // Booking contains binded and validated data. type Booking struct { CheckIn time.Time `form:&amp;quot;check_in&amp;quot; binding:&amp;quot;required,bookabledate&amp;quot; time_format:&amp;quot;2006-01-02&amp;quot;` CheckOut time.Time `form:&amp;quot;check_out&amp;quot; binding:&amp;quot;required,gtfield=CheckIn&amp;quot; time_format:&amp;quot;2006-01-02&amp;quot;` } func bookableDate( v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string, ) bool { if date, ok := field.Interface().(time.Time); ok { today := time.</description>
    </item>
    
    <item>
      <title>Different formats</title>
      <link>https://gin-gonic.com/documentation/response/different_formats/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/response/different_formats/</guid>
      <description>Responding can be as easy as passing just the Status code and a structure representing the data you want to send.
func main() { r := gin.Default() // gin.H is a shortcut for map[string]interface{} r.GET(&amp;quot;/someJSON&amp;quot;, func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{&amp;quot;message&amp;quot;: &amp;quot;hey&amp;quot;, &amp;quot;status&amp;quot;: http.StatusOK}) }) r.GET(&amp;quot;/moreJSON&amp;quot;, func(c *gin.Context) { // You also can use a struct var msg struct { Name string `json:&amp;quot;user&amp;quot;` Message string Number int } msg.Name = &amp;quot;Lena&amp;quot; msg.</description>
    </item>
    
    <item>
      <title>Log middleware</title>
      <link>https://gin-gonic.com/documentation/middleware/custom_middleware/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/middleware/custom_middleware/</guid>
      <description>This simple middleware will print the Status code we send for each request
func Logger() gin.HandlerFunc { return func(c *gin.Context) { t := time.Now() // Set example variable c.Set(&amp;quot;example&amp;quot;, &amp;quot;12345&amp;quot;) // before request c.Next() // after request latency := time.Since(t) log.Print(latency) // access the status we are sending status := c.Writer.Status() log.Println(status) } } func main() { r := gin.New() r.Use(Logger()) r.GET(&amp;quot;/test&amp;quot;, func(c *gin.Context) { example := c.MustGet(&amp;quot;example&amp;quot;).(string) // it would print: &amp;quot;12345&amp;quot; log.</description>
    </item>
    
    <item>
      <title>Using HTTP methods</title>
      <link>https://gin-gonic.com/documentation/router/requests/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/router/requests/</guid>
      <description>Using GET, POST, PUT, PATCH, DELETE and OPTIONS
func main() { // Disable Console Color // gin.DisableConsoleColor() // Creates a gin router with default middleware: // logger and recovery (crash-free) middleware router := gin.Default() router.GET(&amp;quot;/someGet&amp;quot;, getting) router.POST(&amp;quot;/somePost&amp;quot;, posting) router.PUT(&amp;quot;/somePut&amp;quot;, putting) router.DELETE(&amp;quot;/someDelete&amp;quot;, deleting) router.PATCH(&amp;quot;/somePatch&amp;quot;, patching) router.HEAD(&amp;quot;/someHead&amp;quot;, head) router.OPTIONS(&amp;quot;/someOptions&amp;quot;, options) // By default it serves on :8080 unless a // PORT environment variable was defined. router.Run() // router.Run(&amp;quot;:3000&amp;quot;) for a hard coded port }  </description>
    </item>
    
    <item>
      <title>BasicAuth</title>
      <link>https://gin-gonic.com/documentation/middleware/basic_auth/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/middleware/basic_auth/</guid>
      <description>Using BasicAuth() middleware
// simulate some private data var secrets = gin.H{ &amp;quot;foo&amp;quot;: gin.H{&amp;quot;email&amp;quot;: &amp;quot;foo@bar.com&amp;quot;, &amp;quot;phone&amp;quot;: &amp;quot;123433&amp;quot;}, &amp;quot;austin&amp;quot;: gin.H{&amp;quot;email&amp;quot;: &amp;quot;austin@example.com&amp;quot;, &amp;quot;phone&amp;quot;: &amp;quot;666&amp;quot;}, &amp;quot;lena&amp;quot;: gin.H{&amp;quot;email&amp;quot;: &amp;quot;lena@guapa.com&amp;quot;, &amp;quot;phone&amp;quot;: &amp;quot;523443&amp;quot;}, } func main() { r := gin.Default() // Group using gin.BasicAuth() middleware // gin.Accounts is a shortcut for map[string]string authorized := r.Group(&amp;quot;/admin&amp;quot;, gin.BasicAuth(gin.Accounts{ &amp;quot;foo&amp;quot;: &amp;quot;bar&amp;quot;, &amp;quot;austin&amp;quot;: &amp;quot;1234&amp;quot;, &amp;quot;lena&amp;quot;: &amp;quot;hello2&amp;quot;, &amp;quot;manu&amp;quot;: &amp;quot;4321&amp;quot;, })) // /admin/secrets endpoint // hit &amp;quot;localhost:8080/admin/secrets authorized.GET(&amp;quot;/secrets&amp;quot;, func(c *gin.Context) { // get user, it was set by the BasicAuth middleware user := c.</description>
    </item>
    
    <item>
      <title>From query</title>
      <link>https://gin-gonic.com/documentation/binding/query/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/binding/query/</guid>
      <description>ShouldBindQuery function only binds the query params and not the post data. See the detail information.
package main import ( &amp;quot;log&amp;quot; &amp;quot;github.com/gin-gonic/gin&amp;quot; ) type Person struct { Name string `form:&amp;quot;name&amp;quot;` Address string `form:&amp;quot;address&amp;quot;` } func main() { route := gin.Default() route.Any(&amp;quot;/testing&amp;quot;, startPage) route.Run(&amp;quot;:8085&amp;quot;) } func startPage(c *gin.Context) { var person Person if c.ShouldBindQuery(&amp;amp;person) == nil { log.Println(&amp;quot;====== Only Bind By Query String ======&amp;quot;) log.Println(person.Name) log.Println(person.Address) } c.String(200, &amp;quot;Success&amp;quot;) }  </description>
    </item>
    
    <item>
      <title>Grouping routes</title>
      <link>https://gin-gonic.com/documentation/router/grouping_routes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/router/grouping_routes/</guid>
      <description>If your routes have a common prefix you can group them like
func main() { router := gin.Default() // Simple group: v1 v1 := router.Group(&amp;quot;/v1&amp;quot;) { v1.POST(&amp;quot;/login&amp;quot;, loginEndpoint) v1.POST(&amp;quot;/submit&amp;quot;, submitEndpoint) v1.POST(&amp;quot;/read&amp;quot;, readEndpoint) } // Simple group: v2 v2 := router.Group(&amp;quot;/v2&amp;quot;) { v2.POST(&amp;quot;/login&amp;quot;, loginEndpoint) v2.POST(&amp;quot;/submit&amp;quot;, submitEndpoint) v2.POST(&amp;quot;/read&amp;quot;, readEndpoint) } router.Run(&amp;quot;:8080&amp;quot;) }  </description>
    </item>
    
    <item>
      <title>Let&#39;s Encrypt</title>
      <link>https://gin-gonic.com/documentation/extra/lets_encrypt/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/extra/lets_encrypt/</guid>
      <description>Example for 1-line LetsEncrypt HTTPS servers.
package main import ( &amp;quot;log&amp;quot; &amp;quot;github.com/gin-gonic/autotls&amp;quot; &amp;quot;github.com/gin-gonic/gin&amp;quot; ) func main() { r := gin.Default() // Ping handler r.GET(&amp;quot;/ping&amp;quot;, func(c *gin.Context) { c.String(200, &amp;quot;pong&amp;quot;) }) log.Fatal(autotls.Run(r, &amp;quot;example1.com&amp;quot;, &amp;quot;example2.com&amp;quot;)) }  Example for custom autocert manager.
package main import ( &amp;quot;log&amp;quot; &amp;quot;github.com/gin-gonic/autotls&amp;quot; &amp;quot;github.com/gin-gonic/gin&amp;quot; &amp;quot;golang.org/x/crypto/acme/autocert&amp;quot; ) func main() { r := gin.Default() // Ping handler r.GET(&amp;quot;/ping&amp;quot;, func(c *gin.Context) { c.String(200, &amp;quot;pong&amp;quot;) }) m := autocert.Manager{ Prompt: autocert.AcceptTOS, HostPolicy: autocert.</description>
    </item>
    
    <item>
      <title>More JSON</title>
      <link>https://gin-gonic.com/documentation/response/json/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/response/json/</guid>
      <description>SecureJSON Using SecureJSON to prevent json hijacking. Default prepends &amp;quot;while(1),&amp;quot; to response body if the given struct is array values.
func main() { r := gin.Default() // You can also use your own secure json prefix // r.SecureJsonPrefix(&amp;quot;)]}&#39;,\n&amp;quot;) r.GET(&amp;quot;/someJSON&amp;quot;, func(c *gin.Context) { names := []string{&amp;quot;lena&amp;quot;, &amp;quot;austin&amp;quot;, &amp;quot;foo&amp;quot;} // Will output	:	while(1);[&amp;quot;lena&amp;quot;,&amp;quot;austin&amp;quot;,&amp;quot;foo&amp;quot;] c.SecureJSON(http.StatusOK, names) }) // Listen and serve on 0.0.0.0:8080 r.Run(&amp;quot;:8080&amp;quot;) }  JSONP Using JSONP to request data from a server in a different domain.</description>
    </item>
    
    <item>
      <title>Quick start</title>
      <link>https://gin-gonic.com/documentation/getting-started/quick_start/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/getting-started/quick_start/</guid>
      <description>Assume the following code in example.go file
$ cat example.go  package main import &amp;quot;github.com/gin-gonic/gin&amp;quot; func main() { r := gin.Default() r.GET(&amp;quot;/ping&amp;quot;, func(c *gin.Context) { c.JSON(200, gin.H{ &amp;quot;message&amp;quot;: &amp;quot;pong&amp;quot;, }) }) r.Run() // listen and serve on 0.0.0.0:8080 }  You can run the server like so
$ go run example.go  and visit 0.0.0.0:8080/ping on your browser.</description>
    </item>
    
    <item>
      <title>Multiple servers</title>
      <link>https://gin-gonic.com/documentation/extra/multiple_servers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/extra/multiple_servers/</guid>
      <description>See the question and try the following example:
package main import ( &amp;quot;log&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;time&amp;quot; &amp;quot;github.com/gin-gonic/gin&amp;quot; &amp;quot;golang.org/x/sync/errgroup&amp;quot; ) var ( g errgroup.Group ) func router01() http.Handler { e := gin.New() e.Use(gin.Recovery()) e.GET(&amp;quot;/&amp;quot;, func(c *gin.Context) { c.JSON( http.StatusOK, gin.H{ &amp;quot;code&amp;quot;: http.StatusOK, &amp;quot;error&amp;quot;: &amp;quot;Welcome server 01&amp;quot;, }, ) }) return e } func router02() http.Handler { e := gin.New() e.Use(gin.Recovery()) e.GET(&amp;quot;/&amp;quot;, func(c *gin.Context) { c.JSON( http.StatusOK, gin.H{ &amp;quot;code&amp;quot;: http.StatusOK, &amp;quot;error&amp;quot;: &amp;quot;Welcome server 02&amp;quot;, }, ) }) return e } func main() { server01 := &amp;amp;http.</description>
    </item>
    
    <item>
      <title>Parameters in path</title>
      <link>https://gin-gonic.com/documentation/router/parameters_path/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/router/parameters_path/</guid>
      <description>Here is an example that shows how to use path parameters
func main() { router := gin.Default() // This handler will match /user/john but will not match /user/ or /user router.GET(&amp;quot;/user/:name&amp;quot;, func(c *gin.Context) { name := c.Param(&amp;quot;name&amp;quot;) c.String(http.StatusOK, &amp;quot;Hello %s&amp;quot;, name) }) // However, this one will match /user/john/ and also /user/john/send // If no other routers match /user/john, it will redirect to /user/john/ router.GET(&amp;quot;/user/:name/*action&amp;quot;, func(c *gin.Context) { name := c.</description>
    </item>
    
    <item>
      <title>Query or post</title>
      <link>https://gin-gonic.com/documentation/binding/query_post/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/binding/query_post/</guid>
      <description>See the detail information.
package main import ( &amp;quot;log&amp;quot; &amp;quot;time&amp;quot; &amp;quot;github.com/gin-gonic/gin&amp;quot; ) type Person struct { Name string `form:&amp;quot;name&amp;quot;` Address string `form:&amp;quot;address&amp;quot;` Birthday time.Time `form:&amp;quot;birthday&amp;quot; time_format:&amp;quot;2006-01-02&amp;quot; time_utc:&amp;quot;1&amp;quot;` } func main() { route := gin.Default() route.GET(&amp;quot;/testing&amp;quot;, startPage) route.Run(&amp;quot;:8085&amp;quot;) } func startPage(c *gin.Context) { var person Person // If `GET`, only `Form` binding engine (`query`) used. // If `POST`, first checks the `content-type` for `JSON` or `XML`, then uses `Form` (`form-data`). // See more at https://github.</description>
    </item>
    
    <item>
      <title>Static files</title>
      <link>https://gin-gonic.com/documentation/response/static/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/response/static/</guid>
      <description>You can use one of these methods Static(...), StaticFS(...) or StaticFile(...)
func main() { router := gin.Default() router.Static(&amp;quot;/assets&amp;quot;, &amp;quot;./assets&amp;quot;) router.StaticFS(&amp;quot;/more_static&amp;quot;, http.Dir(&amp;quot;my_file_system&amp;quot;)) router.StaticFile(&amp;quot;/favicon.ico&amp;quot;, &amp;quot;./resources/favicon.ico&amp;quot;) // Listen and serve on 0.0.0.0:8080 router.Run(&amp;quot;:8080&amp;quot;) }  </description>
    </item>
    
    <item>
      <title>Vendoring</title>
      <link>https://gin-gonic.com/documentation/getting-started/vendor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/getting-started/vendor/</guid>
      <description> go get govendor
go get github.com/kardianos/govendor   Create your project folder and cd inside  mkdir -p $GOPATH/src/github.com/myusername/project &amp;amp;&amp;amp; cd &amp;quot;$_&amp;quot;  Vendor init your project and add gin
govendor init  govendor fetch github.com/gin-gonic/gin@v1.3  Copy a starting template inside your project
curl https://raw.githubusercontent.com/gin-gonic/gin/master/examples/basic/main.go &amp;gt; main.go   Run your project  go run main.go   </description>
    </item>
    
    <item>
      <title>With goroutines</title>
      <link>https://gin-gonic.com/documentation/middleware/goroutines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/middleware/goroutines/</guid>
      <description>When starting new Goroutines inside a middleware or handler, you SHOULD NOT use the original context inside it, you have to use a read-only copy.
func main() { r := gin.Default() r.GET(&amp;quot;/long_async&amp;quot;, func(c *gin.Context) { // create copy to be used inside the goroutine cCp := c.Copy() go func() { // simulate a long task with time.Sleep(). 5 seconds time.Sleep(5 * time.Second) // note that you are using the copied context &amp;quot;cCp&amp;quot;, IMPORTANT log.</description>
    </item>
    
    <item>
      <title>From a reader</title>
      <link>https://gin-gonic.com/documentation/response/reader/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/response/reader/</guid>
      <description>If you don&amp;rsquo;t have the data you&amp;rsquo;ll send to the response but are reading it from somewhere else you can use DataFromReader(...) method
func main() { router := gin.Default() router.GET(&amp;quot;/someDataFromReader&amp;quot;, func(c *gin.Context) { response, err := http.Get(&amp;quot;https://raw.githubusercontent.com/gin-gonic/logo/master/color.png&amp;quot;) if err != nil || response.StatusCode != http.StatusOK { c.Status(http.StatusServiceUnavailable) return } reader := response.Body contentLength := response.ContentLength contentType := response.Header.Get(&amp;quot;Content-Type&amp;quot;) extraHeaders := map[string]string{ &amp;quot;Content-Disposition&amp;quot;: `attachment; filename=&amp;quot;gopher.png&amp;quot;`, } c.DataFromReader(http.StatusOK, contentLength, contentType, reader, extraHeaders) }) router.</description>
    </item>
    
    <item>
      <title>Graceful restart</title>
      <link>https://gin-gonic.com/documentation/extra/graceful/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/extra/graceful/</guid>
      <description>Do you want to graceful restart or stop your web server? There are some ways this can be done.
We can use fvbock/endless to replace the default ListenAndServe. Refer issue #296 for more details.
router := gin.Default() router.GET(&amp;quot;/&amp;quot;, handler) // [...] endless.ListenAndServe(&amp;quot;:4242&amp;quot;, router)  An alternative to endless:
 manners: A polite Go HTTP server that shuts down gracefully. graceful: Graceful is a Go package enabling graceful shutdown of an http.</description>
    </item>
    
    <item>
      <title>HTML checkboxes</title>
      <link>https://gin-gonic.com/documentation/binding/checkboxes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/binding/checkboxes/</guid>
      <description>See the detail information
main.go
... type myForm struct { Colors []string `form:&amp;quot;colors[]&amp;quot;` } ... func formHandler(c *gin.Context) { var fakeForm myForm c.ShouldBind(&amp;amp;fakeForm) c.JSON(200, gin.H{&amp;quot;color&amp;quot;: fakeForm.Colors}) } ...  form.html
&amp;lt;form action=&amp;quot;/&amp;quot; method=&amp;quot;POST&amp;quot;&amp;gt; &amp;lt;p&amp;gt;Check some colors&amp;lt;/p&amp;gt; &amp;lt;label for=&amp;quot;red&amp;quot;&amp;gt;Red&amp;lt;/label&amp;gt; &amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;colors[]&amp;quot; value=&amp;quot;red&amp;quot; id=&amp;quot;red&amp;quot; /&amp;gt; &amp;lt;label for=&amp;quot;green&amp;quot;&amp;gt;Green&amp;lt;/label&amp;gt; &amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;colors[]&amp;quot; value=&amp;quot;green&amp;quot; id=&amp;quot;green&amp;quot; /&amp;gt; &amp;lt;label for=&amp;quot;blue&amp;quot;&amp;gt;Blue&amp;lt;/label&amp;gt; &amp;lt;input type=&amp;quot;checkbox&amp;quot; name=&amp;quot;colors[]&amp;quot; value=&amp;quot;blue&amp;quot; id=&amp;quot;blue&amp;quot; /&amp;gt; &amp;lt;input type=&amp;quot;submit&amp;quot; /&amp;gt; &amp;lt;/form&amp;gt;  result:
{&amp;quot;color&amp;quot;:[&amp;quot;red&amp;quot;,&amp;quot;green&amp;quot;,&amp;quot;blue&amp;quot;]}  </description>
    </item>
    
    <item>
      <title>Build with jsoniter</title>
      <link>https://gin-gonic.com/documentation/getting-started/jsoninter/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/getting-started/jsoninter/</guid>
      <description>Gin uses encoding/json as default json package but you can change to jsoniter by build from other tags.
$ go build -tags=jsoniter .  </description>
    </item>
    
    <item>
      <title>HTML</title>
      <link>https://gin-gonic.com/documentation/response/html/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/response/html/</guid>
      <description>Using LoadHTMLGlob() or LoadHTMLFiles()
func main() { router := gin.Default() router.LoadHTMLGlob(&amp;quot;templates/*&amp;quot;) //router.LoadHTMLFiles(&amp;quot;templates/template1.html&amp;quot;, &amp;quot;templates/template2.html&amp;quot;) router.GET(&amp;quot;/index&amp;quot;, func(c *gin.Context) { c.HTML(http.StatusOK, &amp;quot;index.tmpl&amp;quot;, gin.H{ &amp;quot;title&amp;quot;: &amp;quot;Main website&amp;quot;, }) }) router.Run(&amp;quot;:8080&amp;quot;) }  templates/index.tmpl
&amp;lt;html&amp;gt; &amp;lt;h1&amp;gt; {{ .title }} &amp;lt;/h1&amp;gt; &amp;lt;/html&amp;gt;  Using templates with same name in different directories
func main() { router := gin.Default() router.LoadHTMLGlob(&amp;quot;templates/**/*&amp;quot;) router.GET(&amp;quot;/posts/index&amp;quot;, func(c *gin.Context) { c.HTML(http.StatusOK, &amp;quot;posts/index.tmpl&amp;quot;, gin.H{ &amp;quot;title&amp;quot;: &amp;quot;Posts&amp;quot;, }) }) router.GET(&amp;quot;/users/index&amp;quot;, func(c *gin.Context) { c.HTML(http.StatusOK, &amp;quot;users/index.tmpl&amp;quot;, gin.</description>
    </item>
    
    <item>
      <title>Multipart/Urlencoded</title>
      <link>https://gin-gonic.com/documentation/binding/multipart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/binding/multipart/</guid>
      <description>package main import ( &amp;quot;github.com/gin-gonic/gin&amp;quot; ) type LoginForm struct { User string `form:&amp;quot;user&amp;quot; binding:&amp;quot;required&amp;quot;` Password string `form:&amp;quot;password&amp;quot; binding:&amp;quot;required&amp;quot;` } func main() { router := gin.Default() router.POST(&amp;quot;/login&amp;quot;, func(c *gin.Context) { // you can bind multipart form with explicit binding declaration: // c.ShouldBindWith(&amp;amp;form, binding.Form) // or you can simply use autobinding with ShouldBind method: var form LoginForm // in this case proper binding will be automatically selected if c.ShouldBind(&amp;amp;form) == nil { if form.</description>
    </item>
    
    <item>
      <title>Query parameters</title>
      <link>https://gin-gonic.com/documentation/router/query_params/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/router/query_params/</guid>
      <description>In order to access the query parameters you can use DefaultQuery and Query methods from *gin.Context
func main() { router := gin.Default() // Query string parameters are parsed using the existing underlying request object. // The request responds to a url matching: /welcome?firstname=Jane&amp;amp;lastname=Doe router.GET(&amp;quot;/welcome&amp;quot;, func(c *gin.Context) { firstname := c.DefaultQuery(&amp;quot;firstname&amp;quot;, &amp;quot;Guest&amp;quot;) lastname := c.Query(&amp;quot;lastname&amp;quot;) // shortcut for c.Request.URL.Query().Get(&amp;quot;lastname&amp;quot;) c.String(http.StatusOK, &amp;quot;Hello %s %s&amp;quot;, firstname, lastname) }) router.Run(&amp;quot;:8080&amp;quot;) }  </description>
    </item>
    
    <item>
      <title>Single binary</title>
      <link>https://gin-gonic.com/documentation/extra/single_binary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/extra/single_binary/</guid>
      <description>You can build a server into a single binary containing templates by using go-assets.
func main() { r := gin.New() t, err := loadTemplate() if err != nil { panic(err) } r.SetHTMLTemplate(t) r.GET(&amp;quot;/&amp;quot;, func(c *gin.Context) { c.HTML(http.StatusOK, &amp;quot;/html/index.tmpl&amp;quot;,nil) }) r.Run(&amp;quot;:8080&amp;quot;) } // loadTemplate loads templates embedded by go-assets-builder func loadTemplate() (*template.Template, error) { t := template.New(&amp;quot;&amp;quot;) for name, file := range Assets.Files { if file.IsDir() || !strings.HasSuffix(name, &amp;quot;.tmpl&amp;quot;) { continue } h, err := ioutil.</description>
    </item>
    
    <item>
      <title>Custom struct</title>
      <link>https://gin-gonic.com/documentation/binding/custom_struct/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/binding/custom_struct/</guid>
      <description>The following example will show how to bind data using custom struct
type StructA struct { FieldA string `form:&amp;quot;field_a&amp;quot;` } type StructB struct { NestedStruct StructA FieldB string `form:&amp;quot;field_b&amp;quot;` } type StructC struct { NestedStructPointer *StructA FieldC string `form:&amp;quot;field_c&amp;quot;` } type StructD struct { NestedAnonyStruct struct { FieldX string `form:&amp;quot;field_x&amp;quot;` } FieldD string `form:&amp;quot;field_d&amp;quot;` } func GetDataB(c *gin.Context) { var b StructB c.Bind(&amp;amp;b) c.JSON(200, gin.H{ &amp;quot;a&amp;quot;: b.NestedStruct, &amp;quot;b&amp;quot;: b.FieldB, }) } func GetDataC(c *gin.</description>
    </item>
    
    <item>
      <title>Form parameters</title>
      <link>https://gin-gonic.com/documentation/router/multipart_form/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/router/multipart_form/</guid>
      <description>The multipart/urlencoded form parameters can be accessed with the DefaultPostForm and PostForm methods
func main() { router := gin.Default() router.POST(&amp;quot;/form_post&amp;quot;, func(c *gin.Context) { message := c.PostForm(&amp;quot;message&amp;quot;) nick := c.DefaultPostForm(&amp;quot;nick&amp;quot;, &amp;quot;anonymous&amp;quot;) c.JSON(200, gin.H{ &amp;quot;status&amp;quot;: &amp;quot;posted&amp;quot;, &amp;quot;message&amp;quot;: message, &amp;quot;nick&amp;quot;: nick, }) }) router.Run(&amp;quot;:8080&amp;quot;) }  </description>
    </item>
    
    <item>
      <title>Multitemplate</title>
      <link>https://gin-gonic.com/documentation/response/multitemplate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/response/multitemplate/</guid>
      <description>Gin allows by default the use of only one html.Template. Check a multitemplate render for using features like go 1.6 block template.</description>
    </item>
    
    <item>
      <title>Server push</title>
      <link>https://gin-gonic.com/documentation/extra/server_push/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/extra/server_push/</guid>
      <description>http.Pusher is supported only go1.8+. See the golang blog for detail information.
package main import ( &amp;quot;html/template&amp;quot; &amp;quot;log&amp;quot; &amp;quot;github.com/gin-gonic/gin&amp;quot; ) var html = template.Must(template.New(&amp;quot;https&amp;quot;).Parse(` &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Https Test&amp;lt;/title&amp;gt; &amp;lt;script src=&amp;quot;/assets/app.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1 style=&amp;quot;color:red;&amp;quot;&amp;gt;Welcome, Ginner!&amp;lt;/h1&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; `)) func main() { r := gin.Default() r.Static(&amp;quot;/assets&amp;quot;, &amp;quot;./assets&amp;quot;) r.SetHTMLTemplate(html) r.GET(&amp;quot;/&amp;quot;, func(c *gin.Context) { if pusher := c.Writer.Pusher(); pusher != nil { // use pusher.Push() to do server push if err := pusher.Push(&amp;quot;/assets/app.js&amp;quot;, nil); err !</description>
    </item>
    
    <item>
      <title>Log routes</title>
      <link>https://gin-gonic.com/documentation/extra/log_routes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/extra/log_routes/</guid>
      <description>The default log of routes is:
[GIN-debug] POST /foo --&amp;gt; main.main.func1 (3 handlers) [GIN-debug] GET /bar --&amp;gt; main.main.func2 (3 handlers) [GIN-debug] GET /status --&amp;gt; main.main.func3 (3 handlers)  If you want to log this information in given format (e.g. JSON, key values or something else), then you can define this format with gin.DebugPrintRouteFunc. In the example below, we log all routes with standard log package but you can use another log tools that suits of your needs.</description>
    </item>
    
    <item>
      <title>Multiple binding</title>
      <link>https://gin-gonic.com/documentation/binding/multiple_binding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/binding/multiple_binding/</guid>
      <description>The normal methods for binding consume c.Request.Body and they cannot be called multiple times.
type formA struct { Foo string `json:&amp;quot;foo&amp;quot; xml:&amp;quot;foo&amp;quot; binding:&amp;quot;required&amp;quot;` } type formB struct { Bar string `json:&amp;quot;bar&amp;quot; xml:&amp;quot;bar&amp;quot; binding:&amp;quot;required&amp;quot;` } func SomeHandler(c *gin.Context) { objA := formA{} objB := formB{} // This c.ShouldBind consumes c.Request.Body and it cannot be reused. if errA := c.ShouldBind(&amp;amp;objA); errA == nil { c.String(http.StatusOK, `the body should be formA`) // Always an error is occurred by this because c.</description>
    </item>
    
    <item>
      <title>Query &#43; form params</title>
      <link>https://gin-gonic.com/documentation/router/query_form/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/router/query_form/</guid>
      <description>Having this server
func main() { router := gin.Default() router.POST(&amp;quot;/post&amp;quot;, func(c *gin.Context) { id := c.Query(&amp;quot;id&amp;quot;) page := c.DefaultQuery(&amp;quot;page&amp;quot;, &amp;quot;0&amp;quot;) name := c.PostForm(&amp;quot;name&amp;quot;) message := c.PostForm(&amp;quot;message&amp;quot;) fmt.Printf(&amp;quot;id: %s; page: %s; name: %s; message: %s&amp;quot;, id, page, name, message) }) router.Run(&amp;quot;:8080&amp;quot;) }  and making a request
POST /post?id=1234&amp;amp;page=1 HTTP/1.1 Content-Type: application/x-www-form-urlencoded name=manu&amp;amp;message=this_is_great  the variables in our handler will be
id: 1234; page: 1; name: manu; message: this_is_great  </description>
    </item>
    
    <item>
      <title>Maps in query or post</title>
      <link>https://gin-gonic.com/documentation/router/query_post_map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/router/query_post_map/</guid>
      <description>The server
func main() { router := gin.Default() router.POST(&amp;quot;/post&amp;quot;, func(c *gin.Context) { ids := c.QueryMap(&amp;quot;ids&amp;quot;) names := c.PostFormMap(&amp;quot;names&amp;quot;) fmt.Printf(&amp;quot;ids: %v; names: %v&amp;quot;, ids, names) }) router.Run(&amp;quot;:8080&amp;quot;) }  the request
POST /post?ids[a]=1234&amp;amp;ids[b]=hello HTTP/1.1 Content-Type: application/x-www-form-urlencoded names[first]=thinkerou&amp;amp;names[second]=tianou  values
ids: map[b:hello a:1234], names: map[second:tianou first:thinkerou]  </description>
    </item>
    
    <item>
      <title>Uploading files</title>
      <link>https://gin-gonic.com/documentation/router/uploading_files/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/router/uploading_files/</guid>
      <description>Here are 2 examples how to upload files to your server
Single file References issue #774 and detail example code.
func main() { router := gin.Default() // Set a lower memory limit for multipart forms (default is 32 MiB) // router.MaxMultipartMemory = 8 &amp;lt;&amp;lt; 20 // 8 MiB router.POST(&amp;quot;/upload&amp;quot;, func(c *gin.Context) { // single file file, _ := c.FormFile(&amp;quot;file&amp;quot;) log.Println(file.Filename) // Upload the file to specific dst. // c.SaveUploadedFile(file, dst) c.</description>
    </item>
    
    <item>
      <title>Middleware</title>
      <link>https://gin-gonic.com/documentation/router/middleware/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/router/middleware/</guid>
      <description>In the middleware section you will find more about them. Here we show how you how to create a router with or without middleware
Blank Gin without middleware by default Use
r := gin.New()  instead of
// Default With the Logger and Recovery middleware already attached r := gin.Default()  Using middleware func main() { // Creates a router without any middleware by default r := gin.New() // Global middleware // Logger middleware will write the logs to gin.</description>
    </item>
    
    <item>
      <title>Logs to file</title>
      <link>https://gin-gonic.com/documentation/router/log_file/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/router/log_file/</guid>
      <description>By changing the gin.DefaultWriter field you can redirect the logs somewhere different from the terminal. Here is an example on how to write the logs to a file.
func main() { // Disable Console Color, you don&#39;t need console color when writing the logs to file. gin.DisableConsoleColor() // Logging to a file. f, _ := os.Create(&amp;quot;gin.log&amp;quot;) gin.DefaultWriter = io.MultiWriter(f) // Use the following code if you need to write the logs to file and console at the same time.</description>
    </item>
    
    <item>
      <title>Redirects</title>
      <link>https://gin-gonic.com/documentation/router/redirect/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://gin-gonic.com/documentation/router/redirect/</guid>
      <description>Issuing a HTTP redirect is easy. Both internal and external locations are supported.
r.GET(&amp;quot;/test&amp;quot;, func(c *gin.Context) { c.Redirect(http.StatusMovedPermanently, &amp;quot;http://www.google.com/&amp;quot;) })  Issuing a Router redirect, use HandleContext like below.
r.GET(&amp;quot;/test&amp;quot;, func(c *gin.Context) { c.Request.URL.Path = &amp;quot;/test2&amp;quot; r.HandleContext(c) }) r.GET(&amp;quot;/test2&amp;quot;, func(c *gin.Context) { c.JSON(200, gin.H{&amp;quot;hello&amp;quot;: &amp;quot;world&amp;quot;}) })  </description>
    </item>
    
  </channel>
</rss>